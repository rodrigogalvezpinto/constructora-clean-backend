  # Reglas Enterprise para Desarrollo .NET

> **Versi√≥n profesional, orientada a equipos enterprise y sistemas cr√≠ticos.**
> Incluye pr√°cticas modernas, contexto, contraejemplos, justificaci√≥n y ejemplos listos para producci√≥n.

  # Reglas Enterprise para Desarrollo .NET

> **Versi√≥n profesional, orientada a equipos enterprise y sistemas cr√≠ticos.**
> Incluye pr√°cticas modernas, contexto, contraejemplos, justificaci√≥n y ejemplos listos para producci√≥n.

## Tabla de Contenido
- [Clean Architecture en .NET 8 - Implementaci√≥n Completa](#clean-architecture-en-net-8---implementaci√≥n-completa)
- [Repository Pattern y CQRS - Ejemplo Real](#repository-pattern-y-cqrs---ejemplo-real)
- [Dependency Injection Avanzado](#dependency-injection-avanzado)
- [Testing de Arquitectura Limpia](#testing-de-arquitectura-limpia)
- [1. Estilo y Estructura de C√≥digo](#1-estilo-y-estructura-de-c√≥digo)
- [2. Convenciones de Nombres](#2-convenciones-de-nombres)
- [3. Uso de C# y .NET](#3-uso-de-c-y-net)
- [4. Sintaxis y Formato](#4-sintaxis-y-formato)
- [5. Manejo de Errores y Validaci√≥n](#5-manejo-de-errores-y-validaci√≥n)
- [6. Dise√±o de APIs y Reglas RESTful](#6-dise√±o-de-apis-y-reglas-restful)
- [7. Paginaci√≥n](#7-paginaci√≥n)
- [8. Optimizaci√≥n de Performance](#8-optimizaci√≥n-de-performance)
- [9. Convenciones Clave](#9-convenciones-clave)
- [10. Testing](#10-testing)
- [11. Seguridad](#11-seguridad)
- [12. Documentaci√≥n de API](#12-documentaci√≥n-de-api)
- [13. CI/CD y Calidad](#13-cicd-y-calidad)
- [14. Git y Pull Requests](#14-git-y-pull-requests)
- [15. Manejo de Secrets y Configuraci√≥n](#15-manejo-de-secrets-y-configuraci√≥n)
- [16. Localizaci√≥n](#16-localizaci√≥n)
- [17. Observabilidad](#17-observabilidad)
- [18. Recursos de Referencia](#18-recursos-de-referencia)
- [19. Historial de Cambios](#19-historial-de-cambios)

---

## Clean Architecture en .NET 8 - Implementaci√≥n Completa

### üèóÔ∏è Estructura de Proyecto Implementada

Este proyecto demuestra la implementaci√≥n perfecta de Clean Architecture en .NET 8:

```
ConstructoraClean/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ ConstructoraClean.Domain/           # üéØ Entidades y Reglas de Negocio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Entities/                       # Entidades del dominio
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Project.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Material.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Purchase.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/                     # Contratos del dominio
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ IProjectRepository.cs
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ IRegionRepository.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ConstructoraClean.Application/      # üéØ Casos de Uso y L√≥gica de Aplicaci√≥n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/                     # Contratos de servicios
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IProjectCostService.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IRegionOverrunService.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Queries/                        # CQRS Queries
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ GetProjectCostsQuery.cs
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GetRegionOverrunsQuery.cs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ConstructoraClean.Infrastructure/   # üéØ Implementaciones T√©cnicas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Data/                          # Contexto de datos
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DapperContext.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Repositories/                   # Repository Pattern
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProjectRepository.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RegionRepository.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Services/                       # Servicios de negocio
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProjectCostService.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RegionOverrunService.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DependencyInjection.cs         # Registro de dependencias
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ ConstructoraClean.Api/              # üéØ Presentaci√≥n y Controllers
‚îÇ       ‚îú‚îÄ‚îÄ Controllers/                    # Controladores delgados
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ HealthController.cs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ProjectsController.cs
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ RegionsController.cs
‚îÇ       ‚îú‚îÄ‚îÄ DTOs/                          # Objetos de transferencia
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ProjectCostsDto.cs
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ RegionOverrunDto.cs
‚îÇ       ‚îî‚îÄ‚îÄ Program.cs                      # Configuraci√≥n de la app
```

### ‚ö° Principios Aplicados

1. **Dependency Inversion Principle**: Las dependencias apuntan hacia el dominio
2. **Single Responsibility**: Cada capa tiene una responsabilidad espec√≠fica
3. **Separation of Concerns**: UI, l√≥gica de negocio y datos est√°n separados
4. **Testability**: Cada capa puede ser testeada independientemente

### üéØ Entidades del Dominio

```csharp
// ConstructoraClean.Domain/Entities/Project.cs
namespace ConstructoraClean.Domain.Entities
{
    /// <summary>
    /// Entidad del dominio que representa un proyecto de construcci√≥n
    /// </summary>
    public class Project
    {
        public int Id { get; set; }
        public int RegionId { get; set; }
        public string Name { get; set; } = string.Empty;
        public decimal Budget { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
    }

    /// <summary>
    /// Entidad del dominio para materiales de construcci√≥n
    /// </summary>
    public class Material
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
    }

    /// <summary>
    /// Entidad del dominio para compras de materiales
    /// </summary>
    public class Purchase
    {
        public int Id { get; set; }
        public int ProjectId { get; set; }
        public int SupplierId { get; set; }
        public int MaterialId { get; set; }
        public int Quantity { get; set; }
        public decimal UnitPrice { get; set; }
        public decimal TotalPrice { get; set; }
        public DateTime PurchaseDate { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
```

### üîÑ Interfaces del Dominio

```csharp
// ConstructoraClean.Domain/Interfaces/IProjectRepository.cs
namespace ConstructoraClean.Domain.Interfaces
{
    /// <summary>
    /// Contrato del repositorio de proyectos - define QU√â se puede hacer
    /// </summary>
    public interface IProjectRepository
    {
        Task<ProjectCostsResult> GetProjectCostsAsync(int projectId, DateTime fromDate, DateTime toDate);
    }

    /// <summary>
    /// Contrato del repositorio de regiones
    /// </summary>
    public interface IRegionRepository
    {
        Task<IEnumerable<RegionOverrunResult>> GetTopOverrunsAsync(int regionId, int limit);
    }
}
```

---

## Repository Pattern y CQRS - Ejemplo Real

### üóÉÔ∏è Repository Pattern Implementado

```csharp
// ConstructoraClean.Infrastructure/Repositories/ProjectRepository.cs
namespace ConstructoraClean.Infrastructure.Repositories
{
    /// <summary>
    /// Implementaci√≥n del repositorio de proyectos usando Dapper
    /// Encapsula el acceso a datos y la l√≥gica de queries complejas
    /// </summary>
    public class ProjectRepository : IProjectRepository
    {
        private readonly DapperContext _context;

        public ProjectRepository(DapperContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        public async Task<ProjectCostsResult> GetProjectCostsAsync(int projectId, DateTime fromDate, DateTime toDate)
        {
            const string sql = @"
                WITH monthly_costs AS (
                    SELECT 
                        TO_CHAR(purchase_date, 'YYYY-MM') AS month,
                        SUM(total_price) AS total_cost
                    FROM purchases
                    WHERE project_id = @ProjectId
                      AND purchase_date >= @FromDate 
                      AND purchase_date <= @ToDate
                    GROUP BY TO_CHAR(purchase_date, 'YYYY-MM')
                ),
                top_materials AS (
                    SELECT 
                        m.name AS material_name,
                        SUM(p.quantity * p.unit_price) AS total_cost
                    FROM purchases p
                    JOIN materials m ON p.material_id = m.material_id
                    WHERE p.project_id = @ProjectId
                      AND p.purchase_date >= @FromDate 
                      AND p.purchase_date <= @ToDate
                    GROUP BY m.name
                    ORDER BY total_cost DESC
                    LIMIT 10
                )
                SELECT 
                    COALESCE(SUM(total_price), 0) AS TotalCost
                FROM purchases 
                WHERE project_id = @ProjectId 
                  AND purchase_date >= @FromDate 
                  AND purchase_date <= @ToDate;
                
                SELECT month, total_cost FROM monthly_costs ORDER BY month;
                
                SELECT material_name, total_cost FROM top_materials;";

            using var connection = _context.CreateConnection();
            
            using var multi = await connection.QueryMultipleAsync(sql, new
            {
                ProjectId = projectId,
                FromDate = fromDate,
                ToDate = toDate
            });

            var totalCost = await multi.ReadSingleAsync<decimal>();
            var monthlyBreakdown = await multi.ReadAsync<MonthlyBreakdownDto>();
            var topMaterials = await multi.ReadAsync<TopMaterialDto>();

            return new ProjectCostsResult
            {
                TotalCost = totalCost,
                MonthlyBreakdown = monthlyBreakdown.ToList(),
                TopMaterials = topMaterials.ToList()
            };
        }
    }
}
```

### üéØ CQRS Pattern con Queries

```csharp
// ConstructoraClean.Application/Queries/GetProjectCostsQuery.cs
namespace ConstructoraClean.Application.Queries
{
    /// <summary>
    /// Query object que encapsula la consulta de costos de proyecto
    /// Implementa CQRS separando las consultas de los comandos
    /// </summary>
    public record GetProjectCostsQuery(int ProjectId, DateTime FromDate, DateTime ToDate);

    /// <summary>
    /// Query para obtener sobrecostos por regi√≥n
    /// </summary>
    public record GetRegionOverrunsQuery(int RegionId, int Limit);
}
```

### üîß Servicios de Aplicaci√≥n

```csharp
// ConstructoraClean.Infrastructure/Services/ProjectCostService.cs
namespace ConstructoraClean.Infrastructure.Services
{
    /// <summary>
    /// Servicio que implementa la l√≥gica de negocio para costos de proyectos
    /// Utiliza el Repository Pattern para acceso a datos
    /// </summary>
    public class ProjectCostService : IProjectCostService
    {
        private readonly IProjectRepository _repository;

        public ProjectCostService(IProjectRepository repository)
        {
            _repository = repository ?? throw new ArgumentNullException(nameof(repository));
        }

        public async Task<ProjectCostsDto> GetProjectCostsAsync(int projectId, DateTime fromDate, DateTime toDate)
        {
            // Validaciones de negocio
            if (projectId <= 0)
                throw new ArgumentException("Project ID must be positive", nameof(projectId));
            
            if (fromDate > toDate)
                throw new ArgumentException("From date cannot be after to date");

            // Delegaci√≥n al repositorio
            var result = await _repository.GetProjectCostsAsync(projectId, fromDate, toDate);
            
            // Mapeo a DTO de respuesta
            return new ProjectCostsDto
            {
                TotalCost = result.TotalCost,
                MonthlyBreakdown = result.MonthlyBreakdown,
                TopMaterials = result.TopMaterials
            };
        }
    }
}
```

---

## Dependency Injection Avanzado

### üîß Configuraci√≥n Modular de DI

```csharp
// ConstructoraClean.Infrastructure/DependencyInjection.cs
namespace ConstructoraClean.Infrastructure
{
    /// <summary>
    /// Configuraci√≥n centralizada de dependency injection para la capa de infraestructura
    /// Implementa el patr√≥n Extension Method para registros modulares
    /// </summary>
    public static class DependencyInjection
    {
        public static IServiceCollection AddInfrastructure(this IServiceCollection services, 
            IConfiguration configuration)
        {
            // Configuraci√≥n de contexto de datos
            services.AddSingleton<DapperContext>(_ => 
                new DapperContext(configuration.GetConnectionString("DefaultConnection")!));

            // Registro de repositorios (Scoped para mantener consistencia por request)
            services.AddScoped<IProjectRepository, ProjectRepository>();
            services.AddScoped<IRegionRepository, RegionRepository>();

            // Registro de servicios de aplicaci√≥n
            services.AddScoped<IProjectCostService, ProjectCostService>();
            services.AddScoped<IRegionOverrunService, RegionOverrunService>();

            return services;
        }
    }
}

// ConstructoraClean.Api/Program.cs
var builder = WebApplication.CreateBuilder(args);

// Registro modular de servicios
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// üéØ Registro de la capa de infraestructura
builder.Services.AddInfrastructure(builder.Configuration);

var app = builder.Build();

// Configuraci√≥n del pipeline HTTP
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

### üéØ Controladores Delgados (Thin Controllers)

```csharp
// ConstructoraClean.Api/Controllers/ProjectsController.cs
namespace ConstructoraClean.Api.Controllers
{
    /// <summary>
    /// Controlador delgado que solo maneja HTTP concerns
    /// La l√≥gica de negocio est√° delegada a servicios
    /// </summary>
    [ApiController]
    [Route("api/v1/[controller]")]
    public class ProjectsController : ControllerBase
    {
        private readonly IProjectCostService _projectCostService;

        public ProjectsController(IProjectCostService projectCostService)
        {
            _projectCostService = projectCostService ?? throw new ArgumentNullException(nameof(projectCostService));
        }

        /// <summary>
        /// Obtiene los costos de un proyecto en un rango de fechas
        /// </summary>
        /// <param name="projectId">ID del proyecto</param>
        /// <param name="from">Fecha de inicio</param>
        /// <param name="to">Fecha de fin</param>
        /// <returns>Costos del proyecto con desglose mensual y top materiales</returns>
        [HttpGet("{projectId}/costs")]
        public async Task<ActionResult<ProjectCostsDto>> GetProjectCosts(
            int projectId, 
            [FromQuery] DateTime from, 
            [FromQuery] DateTime to)
        {
            try
            {
                var result = await _projectCostService.GetProjectCostsAsync(projectId, from, to);
                return Ok(result);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(new { error = ex.Message });
            }
            catch (Exception ex)
            {
                // Log the exception (omitted for brevity)
                return StatusCode(500, new { error = "Internal server error" });
            }
        }
    }
}
```

---

## Testing de Arquitectura Limpia

### üß™ Testing con Mocks del Repository Pattern

```csharp
// ConstructoraClean.Api.Tests/Services/ProjectCostServiceTests.cs
namespace ConstructoraClean.Api.Tests.Services
{
    /// <summary>
    /// Tests unitarios del servicio de costos de proyectos
    /// Demuestra testing de Clean Architecture con mocking de repositorios
    /// </summary>
    public class ProjectCostServiceTests
    {
        private readonly Mock<IProjectRepository> _mockRepository;
        private readonly ProjectCostService _service;

        public ProjectCostServiceTests()
        {
            _mockRepository = new Mock<IProjectRepository>();
            _service = new ProjectCostService(_mockRepository.Object);
        }

        [Fact]
        public async Task GetProjectCostsAsync_WithValidParameters_ReturnsCorrectData()
        {
            // Arrange
            var projectId = 1;
            var fromDate = new DateTime(2023, 1, 1);
            var toDate = new DateTime(2023, 12, 31);
            
            var expectedResult = new ProjectCostsResult
            {
                TotalCost = 1000m,
                MonthlyBreakdown = new List<MonthlyBreakdownDto>
                {
                    new() { Month = "2023-01", TotalCost = 500m },
                    new() { Month = "2023-02", TotalCost = 500m }
                },
                TopMaterials = new List<TopMaterialDto>
                {
                    new() { MaterialName = "Cement", TotalCost = 600m },
                    new() { MaterialName = "Steel", TotalCost = 400m }
                }
            };

            _mockRepository
                .Setup(x => x.GetProjectCostsAsync(projectId, fromDate, toDate))
                .ReturnsAsync(expectedResult);

            // Act
            var result = await _service.GetProjectCostsAsync(projectId, fromDate, toDate);

            // Assert
            result.Should().NotBeNull();
            result.TotalCost.Should().Be(1000m);
            result.MonthlyBreakdown.Should().HaveCount(2);
            result.TopMaterials.Should().HaveCount(2);
            
            _mockRepository.Verify(x => x.GetProjectCostsAsync(projectId, fromDate, toDate), Times.Once);
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(0)]
        public async Task GetProjectCostsAsync_WithInvalidProjectId_ThrowsArgumentException(int invalidProjectId)
        {
            // Arrange
            var fromDate = DateTime.Now.AddMonths(-1);
            var toDate = DateTime.Now;

            // Act & Assert
            await FluentActions
                .Invoking(() => _service.GetProjectCostsAsync(invalidProjectId, fromDate, toDate))
                .Should()
                .ThrowAsync<ArgumentException>()
                .WithMessage("*Project ID must be positive*");
        }
    }
}
```

### üéØ Testing de Controladores con CQRS

```csharp
// ConstructoraClean.Api.Tests/Controllers/ProjectsControllerTests.cs
namespace ConstructoraClean.Api.Tests.Controllers
{
    /// <summary>
    /// Tests de controladores que validan solo HTTP concerns
    /// La l√≥gica de negocio se testea en los servicios
    /// </summary>
    public class ProjectsControllerTests
    {
        private readonly Mock<IProjectCostService> _mockService;
        private readonly ProjectsController _controller;

        public ProjectsControllerTests()
        {
            _mockService = new Mock<IProjectCostService>();
            _controller = new ProjectsController(_mockService.Object);
        }

        [Fact]
        public async Task GetProjectCosts_WithValidParameters_ReturnsOkResult()
        {
            // Arrange
            var projectId = 1;
            var fromDate = new DateTime(2023, 1, 1);
            var toDate = new DateTime(2023, 12, 31);
            
            var expectedDto = TestDataBuilder.CreateProjectCostsDto();
            
            _mockService
                .Setup(x => x.GetProjectCostsAsync(projectId, fromDate, toDate))
                .ReturnsAsync(expectedDto);

            // Act
            var result = await _controller.GetProjectCosts(projectId, fromDate, toDate);

            // Assert
            result.Result.Should().BeOfType<OkObjectResult>();
            var okResult = result.Result as OkObjectResult;
            okResult!.Value.Should().BeEquivalentTo(expectedDto);
        }

        [Fact]
        public async Task GetProjectCosts_WithServiceException_ReturnsBadRequest()
        {
            // Arrange
            var projectId = -1;
            var fromDate = DateTime.Now;
            var toDate = DateTime.Now;

            _mockService
                .Setup(x => x.GetProjectCostsAsync(projectId, fromDate, toDate))
                .ThrowsAsync(new ArgumentException("Project ID must be positive"));

            // Act
            var result = await _controller.GetProjectCosts(projectId, fromDate, toDate);

            // Assert
            result.Result.Should().BeOfType<BadRequestObjectResult>();
        }
    }
}
```

### üîß Helper para Generaci√≥n de Datos de Test

```csharp
// ConstructoraClean.Api.Tests/Helpers/TestDataBuilder.cs
namespace ConstructoraClean.Api.Tests.Helpers
{
    /// <summary>
    /// Builder pattern para generar datos de test consistentes
    /// Utiliza Bogus para datos realistas que siguen las reglas del dominio
    /// </summary>
    public static class TestDataBuilder
    {
        public static readonly Faker<ProjectCostsDto> ProjectCostsDtoFaker = new Faker<ProjectCostsDto>()
            .RuleFor(x => x.TotalCost, f => f.Random.Decimal(1000, 100000))
            .RuleFor(x => x.MonthlyBreakdown, f => MonthlyBreakdownDtoFaker.Generate(f.Random.Int(1, 12)))
            .RuleFor(x => x.TopMaterials, f => TopMaterialDtoFaker.Generate(f.Random.Int(1, 10)));

        public static readonly Faker<MonthlyBreakdownDto> MonthlyBreakdownDtoFaker = new Faker<MonthlyBreakdownDto>()
            .RuleFor(x => x.Month, f => f.Date.Recent(365).ToString("yyyy-MM"))
            .RuleFor(x => x.TotalCost, f => f.Random.Decimal(100, 10000));

        public static readonly Faker<TopMaterialDto> TopMaterialDtoFaker = new Faker<TopMaterialDto>()
            .RuleFor(x => x.MaterialName, f => f.Commerce.ProductMaterial())
            .RuleFor(x => x.TotalCost, f => f.Random.Decimal(50, 5000));

        public static ProjectCostsDto CreateProjectCostsDto() => ProjectCostsDtoFaker.Generate();
    }
}
```

---

## Principios RESTful Fundamentales

REST (Transferencia de Estado Representacional) es un estilo arquitect√≥nico para el dise√±o de APIs que promueve:

- **Arquitectura cliente-servidor**: Separaci√≥n clara entre frontend y backend.
- **Apatridia**: El servidor no almacena estado de cliente entre solicitudes; cada request contiene toda la informaci√≥n necesaria.
- **Interfaz uniforme**: Uso consistente de URIs, m√©todos HTTP y formatos de datos.
- **Cacheabilidad**: Las respuestas pueden ser expl√≠citamente marcadas como cacheables o no.
- **Sistema en capas**: Permite la existencia de proxies, balanceadores y capas intermedias.
- **C√≥digo bajo demanda (opcional)**: El servidor puede enviar c√≥digo ejecutable al cliente (poco utilizado en APIs modernas).

> **Referencia:** [REST Architectural Constraints](https://restfulapi.net/rest-architectural-constraints/)

---

## Arquitectura y Estructura de Carpetas Recomendada (.NET 8+)

En **2025**, las mejores pr√°cticas para la **estructura de archivos y paquetes** en un proyecto **ASP.NET Core REST API** est√°n enfocadas en mantener el c√≥digo limpio, escalable, mantenible y f√°cil de testear. Esto implica seguir principios como **SOLID**, **separaci√≥n de responsabilidades**, **Clean Architecture**, y el uso adecuado de **capas l√≥gicas** del proyecto.

A continuaci√≥n se muestra una estructura recomendada basada en est√°ndares actuales y patrones modernos como CQRS, MediatR, DDD, repositorios, inyecci√≥n de dependencias, DTOs, etc.

### üß± Estructura Base Recomendada
```
MyCompany.MyProject/
‚îú‚îÄ‚îÄ MyCompany.MyProject.Api/             üëâ Capa de presentaci√≥n: controladores, middleware, startup
‚îú‚îÄ‚îÄ MyCompany.MyProject.Application/      üëâ L√≥gica de negocio, servicios, comandos, consultas, validaciones
‚îú‚îÄ‚îÄ MyCompany.MyProject.Domain/           üëâ Entidades, interfaces de dominio, reglas de negocio
‚îú‚îÄ‚îÄ MyCompany.MyProject.Infrastructure/   üëâ Implementaciones t√©cnicas: EF Core, repositorios, external services, logging, etc.
‚îú‚îÄ‚îÄ MyCompany.MyProject.Shared/           üëâ Configuraciones comunes, constantes, tipos compartidos
‚îú‚îÄ‚îÄ MyCompany.MyProject.UnitTests/        üëâ Pruebas unitarias a nivel de aplicaci√≥n
‚îú‚îÄ‚îÄ MyCompany.MyProject.IntegrationTests/ üëâ Pruebas de integraci√≥n con base de datos, APIs, etc.
```

### üìÅ Desglose por Carpeta

#### 1. `MyCompany.MyProject.Api`  
> Capa de presentaci√≥n. Controladores, endpoints, autenticaci√≥n, Swagger, etc.
- `Controllers/` ‚Äì Controladores REST `[ApiController]`, `[Route]`
- `Extensions/` ‚Äì M√©todos de extensi√≥n para DI y pipeline
- `Filters/` ‚Äì Filtros globales, manejo de excepciones
- `DTOs/` ‚Äì Objetos de transferencia de datos
- `Program.cs` ‚Äì Configuraci√≥n de servicios y pipeline HTTP
- `appsettings.json` ‚Äì Configuraci√≥n por entorno

**Ejemplo de controlador con MediatR:**
```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IMediator _mediator;
    public ProductsController(IMediator mediator) => _mediator = mediator;

    [HttpGet("{id}")]
    public async Task<IActionResult> GetProduct(int id)
    {
        var result = await _mediator.Send(new GetProductQuery(id));
        return Ok(result);
    }
}
```

#### 2. `MyCompany.MyProject.Application`
> L√≥gica de negocio, casos de uso, comandos, consultas, validaciones.
- `Commands/`, `Queries/`, `Validators/`, `Interfaces/`, `Models/`, `Exceptions/`

#### 3. `MyCompany.MyProject.Domain`
> Entidades, objetos de valor, repositorios, eventos de dominio.
- `Entities/`, `ValueObjects/`, `Enums/`, `Events/`, `Repositories/`

**Ejemplo de interfaz de repositorio:**
```csharp
public interface IProductRepository
{
    Task<Product> GetByIdAsync(int id);
    Task AddAsync(Product product);
    Task UpdateAsync(Product product);
}
```

#### 4. `MyCompany.MyProject.Infrastructure`
> Implementaci√≥n t√©cnica: acceso a BD, logs, servicios externos.
- `Data/`, `Repositories/`, `Services/`, `Persistence/`, `Logging/`, `Configuration/`

#### 5. `MyCompany.MyProject.Shared`
> Componentes compartidos entre todas las capas.
- `Constants/`, `Types/`, `Settings/`, `Exceptions/`, `Extensions/`

#### 6. `MyCompany.MyProject.UnitTests`
> Pruebas unitarias de l√≥gica de negocio.
- `Application/`, `Domain/`, `Shared/`

#### 7. `MyCompany.MyProject.IntegrationTests`
> Pruebas con base de datos, APIs, servicios externos.
- `Api/`, `Infrastructure/`, `Fixtures/`

### üß© Patrones y Herramientas Recomendadas en 2025

| Prop√≥sito | Recomendaci√≥n |
|----------|----------------|
| Inyecci√≥n de dependencias | Built-in DI o Autofac |
| ORM | Entity Framework Core |
| Validaci√≥n | FluentValidation |
| Comunicaci√≥n entre componentes | MediatR |
| Documentaci√≥n | Swashbuckle + XML comments |
| Logging | Serilog o ILogger<T> |
| Seguridad | JWT Bearer, IdentityServer |
| Testing | xUnit / NUnit + Moq |
| Configuraci√≥n | IOptions<T> + appsettings.json |
| Pipeline HTTP | Middleware personalizado, filtros |
| CI/CD | GitHub Actions / Azure DevOps |

### ‚úÖ Ejemplo visual de estructura final
```
/src
  /MyCompany.MyProject.Api
    Controllers/
    Extensions/
    Filters/
    DTOs/
    Program.cs
    appsettings.json

  /MyCompany.MyProject.Application
    Commands/
    Queries/
    Validators/
    Models/
    Exceptions/

  /MyCompany.MyProject.Domain
    Entities/
    ValueObjects/
    Enums/
    Repositories/

  /MyCompany.MyProject.Infrastructure
    Data/
    Repositories/
    Services/
    Configuration/

  /MyCompany.MyProject.Shared
    Constants/
    Types/
    Extensions/

/test
  /MyCompany.MyProject.UnitTests
  /MyCompany.MyProject.IntegrationTests
```

### üìå Notas y advertencias
- En proyectos peque√±os, puedes usar una sola soluci√≥n y carpetas internas.
- Usa **partial classes** o **features folders** si prefieres agrupar por funcionalidad.
- Considera Minimal APIs en microservicios.
- Mant√©n controladores delgados; delega l√≥gica a Application Layer.
- Usa DTOs para exponer datos, nunca entidades de dominio.
- Implementa versionado de API si esperas cambios futuros.
- No mezcles l√≥gica de infraestructura en Application o Domain.
- Documenta y automatiza con Swagger/OpenAPI.

---

## üö´ Errores Comunes y Anti-Patrones a Evitar

Evitar errores comunes y anti-patrones es clave para escribir c√≥digo limpio, mantenible y escalable. A continuaci√≥n se listan algunos de los errores m√°s frecuentes en proyectos ASP.NET Core, junto con explicaciones y c√≥mo corregirlos.

---

### 1. **Exponer directamente entidades de dominio como DTOs**
> ‚ùå Error: Devolver entidades del modelo de dominio o EF Core directamente en controladores.
>
> üí° Por qu√© es malo:
- Exposici√≥n innecesaria de datos sensibles o relacionados.
- Acoplamiento entre la capa de persistencia y la API.
- Imposibilidad de versionar la API sin romper compatibilidad.

‚úÖ **Soluci√≥n:** Usa **DTOs (Data Transfer Objects)** para mapear solo los campos necesarios en las respuestas HTTP.

```csharp
// ‚ùå Mal ejemplo
[HttpGet("{id}")]
public async Task<ActionResult<User>> GetUser(int id)
{
    return await _context.Users.FindAsync(id);
}

// ‚úÖ Buen ejemplo
[HttpGet("{id}")]
public async Task<ActionResult<UserDto>> GetUser(int id)
{
    var user = await _context.Users.FindAsync(id);
    return _mapper.Map<UserDto>(user);
}
```

---

### 2. **Usar `var` cuando el tipo no es evidente**
> ‚ùå Error: Usar `var` sin claridad sobre el tipo devuelto.
>
> üí° Por qu√© es malo:
- Reduce la legibilidad del c√≥digo.
- Dificulta la comprensi√≥n r√°pida de tipos complejos o an√≥nimos.

‚úÖ **Soluci√≥n:** Usa `var` solo cuando el tipo sea evidente por el lado derecho de la asignaci√≥n.

```csharp
// ‚ùå Mal ejemplo
var result = SomeComplexMethod(); // ¬øqu√© tipo devuelve?

// ‚úÖ Buen ejemplo
var message = "Hola mundo"; // string es claro
IEnumerable<int> numbers = GetNumbers(); // tipo expl√≠cito si no es obvio
```

---

### 3. **No usar `async/await` correctamente**
> ‚ùå Error: Bloquear llamadas as√≠ncronas usando `.Result` o `.Wait()`.
>
> üí° Por qu√© es malo:
- Puede causar **deadlocks** en aplicaciones web.
- Reduce el rendimiento al bloquear hilos.

‚úÖ **Soluci√≥n:** Siempre usa `async/await` en m√©todos I/O-bound y evita `.Result`.

```csharp
// ‚ùå Mal ejemplo
var data = GetDataAsync().Result;

// ‚úÖ Buen ejemplo
var data = await GetDataAsync();
```

---

### 4. **Capturar excepciones gen√©ricas (`catch (Exception ex)`)**
> ‚ùå Error: Capturar todas las excepciones sin discriminaci√≥n.
>
> üí° Por qu√© es malo:
- Oculta errores graves que deber√≠an detener la ejecuci√≥n.
- No permite manejar errores espec√≠ficos de forma adecuada.

‚úÖ **Soluci√≥n:** Captura solo excepciones espec√≠ficas y re-lanza cuando no puedas manejarlas.

```csharp
// ‚ùå Mal ejemplo
try
{
    // ...
}
catch (Exception ex)
{
    Log(ex);
}

// ‚úÖ Buen ejemplo
try
{
    // ...
}
catch (InvalidOperationException ex)
{
    Log("Operaci√≥n inv√°lida", ex);
    throw;
}
```

---

### 5. **Uso incorrecto de `using` y recursos no gestionados**
> ‚ùå Error: No liberar recursos con `using` o hacerlo manualmente.
>
> üí° Por qu√© es malo:
- Fugas de memoria o recursos.
- C√≥digo m√°s propenso a errores.

‚úÖ **Soluci√≥n:** Usa `using` siempre que trabajes con objetos que implementen `IDisposable`.

```csharp
// ‚ùå Mal ejemplo
var reader = new StreamReader("file.txt");
var content = reader.ReadToEnd();

// ‚úÖ Buen ejemplo
using var reader = new StreamReader("file.txt");
var content = await reader.ReadToEndAsync();
```

---

### 6. **Colocar `using` dentro de `namespace`**
> ‚ùå Error: Incluir directivas `using` dentro de un bloque `namespace`.
>
> üí° Por qu√© es malo:
- Puede causar ambig√ºedades en resoluci√≥n de tipos.
- Genera errores dif√≠ciles de rastrear en ciertos casos.

‚úÖ **Soluci√≥n:** Coloca siempre las directivas `using` **fuera** del bloque `namespace`.

```csharp
// ‚ùå Mal ejemplo
namespace MyNamespace
{
    using System.Linq;
    // ...
}

// ‚úÖ Buen ejemplo
using System.Linq;

namespace MyNamespace
{
    // ...
}
```

---

### 7. **Ignorar convenciones de estilo de c√≥digo**
> ‚ùå Error: No seguir convenciones de nomenclatura, formato o estilo.
>
> üí° Por qu√© es malo:
- Reducci√≥n de legibilidad.
- Confusi√≥n en equipos colaborativos.
- Dificultad para mantener consistencia.

‚úÖ **Soluci√≥n:** Usa `.editorconfig`, analizadores de c√≥digo y sigue gu√≠as oficiales de estilo.

Ejemplo:
```csharp
// ‚ùå Mal ejemplo
int myvar = 0;
string MY_CONSTANT = "BAD";

// ‚úÖ Buen ejemplo
int myVar = 0;
const string MyConstant = "GOOD";
```

---

### 8. **Controladores gruesos (fat controllers)**
> ‚ùå Error: Colocar toda la l√≥gica dentro del controlador.
>
> üí° Por qu√© es malo:
- Acoplamiento alto.
- Dificultad para testear.
- Violaci√≥n del principio de responsabilidad √∫nica.

‚úÖ **Soluci√≥n:** Mueve la l√≥gica de negocio a servicios o handlers, mant√©n controladores delgados.

```csharp
// ‚ùå Mal ejemplo
[ApiController]
[Route("[controller]")]
public class OrderController : ControllerBase
{
    [HttpPost]
    public IActionResult CreateOrder([FromBody] OrderDto dto)
    {
        if (dto == null || dto.Items.Count == 0)
            return BadRequest("Order is empty");

        using var context = new AppDbContext();
        var order = new Order { ... };
        context.Orders.Add(order);
        context.SaveChanges();
        return Ok(order.Id);
    }
}

// ‚úÖ Buen ejemplo
[ApiController]
[Route("[controller]")]
public class OrderController : ControllerBase
{
    private readonly IOrderService _orderService;

    public OrderController(IOrderService orderService) =>
        _orderService = orderService;

    [HttpPost]
    public async Task<IActionResult> CreateOrder(OrderDto dto) =>
        Ok(await _orderService.CreateOrderAsync(dto));
}
```

---

### 9. **Uso inapropiado de LINQ**
> ‚ùå Error: Usar m√∫ltiples `ToList()` o `Where()` en memoria, o ignorar el orden de filtrado.
>
> üí° Por qu√© es malo:
- Rendimiento deficiente al traer datos innecesarios desde la BD.
- P√©rdida de eficiencia en consultas.

‚úÖ **Soluci√≥n:** Filtra primero, proyecta despu√©s, y deja que EF Core traduzca las expresiones.

```csharp
// ‚ùå Mal ejemplo
var customers = db.Customers.ToList()
    .Where(c => c.City == "Madrid");

// ‚úÖ Buen ejemplo
var customers = db.Customers
    .Where(c => c.City == "Madrid")
    .Select(c => new CustomerDto { Name = c.Name })
    .ToList();
```

---

### 10. **No validar modelos ni devolver errores consistentes**
> ‚ùå Error: Ignorar validaciones o devolver formatos de error inconsistentes.
>
> üí° Por qu√© es malo:
- Clientes tienen dificultad para interpretar errores.
- Falta de estandarizaci√≥n.

‚úÖ **Soluci√≥n:** Usa Data Annotations o FluentValidation, e implementa middleware global de excepciones.

```csharp
// ‚ùå Mal ejemplo
if (model == null)
    return StatusCode(500);

// ‚úÖ Buen ejemplo
if (!ModelState.IsValid)
    return ValidationProblem(ModelState);
```

---

## üß∞ Herramientas Recomendadas para Prevenir Estos Errores

| Herramienta | Prop√≥sito |
|------------|-----------|
| **Roslyn Analyzers** | Detectar violaciones de estilo y patrones |
| **.editorconfig** | Mantener coherencia en todo el equipo |
| **FluentValidation** | Validaciones robustas y centralizadas |
| **MediatR / CQRS** | Separar comando de consulta y evitar controladores gruesos |
| **Serilog / ILogger<T>** | Logging estructurado y f√°cil de analizar |
| **Swashbuckle / OpenAPI** | Documentaci√≥n autom√°tica de errores y DTOs |

---

## üìù Nota sobre estrategia de testing en proyectos reales

Si el proyecto est√° en fase de cambios frecuentes o desarrollo acelerado, es v√°lido priorizar la construcci√≥n y estabilizaci√≥n de la funcionalidad principal antes de invertir mucho tiempo en tests automatizados. Una vez que la aplicaci√≥n est√© estable y no requiera cambios estructurales, es el momento ideal para crear una suite de pruebas robusta (unitarias, integraci√≥n y end-to-end).

Esto evita el doble trabajo de rehacer tests cada vez que cambian los requisitos y asegura que los tests realmente validen el comportamiento final y estable de la aplicaci√≥n.

**Sin embargo:** En proyectos cr√≠ticos, regulados o de misi√≥n cr√≠tica, el enfoque TDD (test-driven development) o tests concurrentes pueden seguir siendo obligatorios.

---

## üöÄ Gu√≠a r√°pida: 10 pasos para arrancar un proyecto ASP.NET Core REST profesional

1. **Recopila y documenta todos los requisitos de negocio.**
   - Define entidades, casos de uso, reglas, usuarios y restricciones.
2. **Dise√±a la arquitectura y estructura de carpetas.**
   - Aplica Clean Architecture: separa Api, Application, Domain, Infrastructure, Shared, Tests.
3. **Crea la soluci√≥n y proyectos base en .NET.**
   - Usa `dotnet new sln` y agrega proyectos (`Api`, `Application`, `Domain`, etc.).
4. **Define modelos de dominio y DTOs principales.**
   - No expongas entidades directamente; usa AutoMapper si es posible.
5. **Implementa la capa de infraestructura m√≠nima.**
   - Configura acceso a datos (EF Core, Dapper, etc.), logging, configuraci√≥n.
6. **Desarrolla los endpoints y l√≥gica de negocio.**
   - Mant√©n controladores delgados; delega l√≥gica a Application Layer.
7. **Configura seguridad, validaci√≥n y manejo de errores global.**
   - A√±ade autenticaci√≥n, autorizaci√≥n, validaciones (FluentValidation), middleware de errores.
8. **Documenta la API con Swagger/OpenAPI.**
   - Habilita Swashbuckle, agrega comentarios XML y ejemplos.
9. **Cuando la aplicaci√≥n est√© estable, implementa la suite de tests.**
    - Crea tests unitarios e integraci√≥n para los casos cr√≠ticos y flujos principales.
10. **Automatiza tareas repetitivas.**
    - Usa linters, analizadores de c√≥digo, plantillas de PR y pipelines de CI/CD si aplica.

> **Consejo Senior:** Prioriza la claridad, separaci√≥n de responsabilidades y automatizaci√≥n. No temas refactorizar antes de escribir tests si el c√≥digo a√∫n est√° en movimiento.

---

## 1. Estilo y Estructura de C√≥digo

- Utiliza `.editorconfig` y Roslyn Analyzers para aplicar reglas de estilo de forma autom√°tica.
- Escribe c√≥digo idiom√°tico, conciso y legible.
- Estructura el proyecto por capas (Controladores, Servicios, Dominio, Datos, etc.).
- Prefiere patrones orientados a objetos y funcionales seg√∫n el contexto.
- **Ejemplo recomendado:**
  ```csharp
  public record PedidoDto(int Id, string Cliente, decimal Total);
  ```

## 2. Convenciones de Nombres

- PascalCase para clases, m√©todos y miembros p√∫blicos.
- camelCase para variables locales y campos privados.
- MAY√öSCULAS para constantes.
- Interfaces con prefijo "I" (ej: `IUserService`).
- **Ejemplo incorrecto:**
  - ‚ùå `public class usuarioService {}`

## 3. Uso de C# y .NET

- Utiliza C# 10+ (records, pattern matching, namespaces a nivel de archivo, etc.).
- Prefiere LINQ y expresiones lambda.
- Usa Minimal APIs para microservicios o endpoints simples:
  ```csharp
  var app = WebApplication.CreateBuilder(args).Build();
  app.MapGet("/api/v1/proveedores", (IProveedorService svc, int page, int pageSize) => ...);
  ```

## 4. Sintaxis y Formato

- Sigue las [Convenciones de Estilo de C# de Microsoft](https://docs.microsoft.com/es-es/dotnet/csharp/fundamentals/coding-style/coding-conventions).
- Usa `var` cuando el tipo es evidente.
- Usa interpolaci√≥n de cadenas y null-coalescing.
- Aplica reglas de formato con `.editorconfig`.

## 5. Manejo de Errores y Validaci√≥n

> **Justificaci√≥n:** Las respuestas uniformes facilitan el manejo de errores en frontend y el logging centralizado.

- Usa excepciones solo para casos excepcionales, no para control de flujo.
- Implementa middleware global para el manejo de errores.
- Devuelve errores con estructura est√°ndar:
  ```json
  {
    "success": false,
    "error": {
      "code": "ValidationError",
      "message": "Uno o m√°s errores de validaci√≥n ocurrieron.",
      "details": ["El campo Email es requerido"]
    }
  }
  ```
- No expongas stacktrace ni mensajes internos en producci√≥n.
- Utiliza Serilog (o similar) para logging estructurado:
  ```csharp
  Log.Logger = new LoggerConfiguration()
      .Enrich.FromLogContext()
      .WriteTo.Console()
      .CreateLogger();
  ```

## 6. Dise√±o de APIs y Reglas RESTful

> **Justificaci√≥n:** Seguir est√°ndares globales facilita la integraci√≥n y el mantenimiento.

- ‚úÖ Usa `kebab-case` para recursos: `/api/user-profiles`
- ‚ùå No uses camelCase ni snake_case en URIs.
- ‚úÖ Usa plural: `/api/orders`
- ‚ùå No uses verbos: `/api/getOrders`
- ‚úÖ Versiona la API: `/api/v1/orders`
- ‚ùå No mezcles versiones en la misma ruta.
- M√©todos HTTP: GET, POST, PUT, PATCH, DELETE.
- C√≥digos de estado: 200, 201, 204, 400, 404, 500.
- Usa `[ApiController]` y `[Route]` para el ruteo.
- Documenta todos los endpoints y modelos en Swagger.

### Diferencia entre PUT y PATCH

| Caracter√≠stica | PUT (Reemplazo completo) | PATCH (Actualizaci√≥n parcial) |
|---|---|---|
| Objetivo | Reemplaza todo el recurso | Modifica campos espec√≠ficos |
| Cuerpo de la solicitud | Objeto completo | Solo los campos a modificar |
| Idempotente | S√≠ | No necesariamente |
| Caso de uso | Actualizaci√≥n total | Cambios parciales |

**Ejemplo PUT:**
```csharp
[HttpPut("{id}")]
public IActionResult UpdateUser(int id, UserDto dto) {
    // Reemplaza todo el usuario
}
```
**Ejemplo PATCH:**
```csharp
[HttpPatch("{id}")]
public IActionResult PatchUser(int id, JsonPatchDocument<UserDto> patch) {
    // Modifica s√≥lo algunos campos
}
```

### Ejemplo de rutas anidadas y jer√°rquicas

- Bueno: `/api/users/{userId}/orders/{orderId}` (pedido de un usuario espec√≠fico)
- Malo: `/api/orders/{orderId}` (si la relaci√≥n depende del usuario)

### Par√°metros de ruta vs. par√°metros de consulta
- **Ruta:** Identifican recursos (`/api/users/{id}`)
- **Query:** Filtran, ordenan o paginan (`/api/users?role=admin&page=2`)

### Ejemplo completo: CRUD, modelos, servicio e inyecci√≥n de dependencias en .NET 8

#### 1. Modelo de Dominio y DTO
```csharp
// OurHero.cs
public class OurHero {
    public int Id { get; set; }
    [Required]
    public string FirstName { get; set; }
    public string LastName { get; set; } = string.Empty;
    public bool IsActive { get; set; } = true;
}

// AddUpdateOurHero.cs
public class AddUpdateOurHero {
    [Required]
    public string FirstName { get; set; }
    public string LastName { get; set; } = string.Empty;
    public bool IsActive { get; set; } = true;
}
```

#### 2. Servicio de negocio en memoria
```csharp
public interface IOurHeroService {
    List<OurHero> GetAll(bool? isActive = null);
    OurHero? GetById(int id);
    OurHero Add(AddUpdateOurHero dto);
    OurHero? Update(int id, AddUpdateOurHero dto);
    bool Delete(int id);
}

public class OurHeroService : IOurHeroService {
    private readonly List<OurHero> _heroes = new() { new OurHero { Id = 1, FirstName = "Test" } };
    public List<OurHero> GetAll(bool? isActive = null) =>
        isActive == null ? _heroes : _heroes.Where(h => h.IsActive == isActive).ToList();
    public OurHero? GetById(int id) => _heroes.FirstOrDefault(h => h.Id == id);
    public OurHero Add(AddUpdateOurHero dto) {
        var hero = new OurHero {
            Id = _heroes.Any() ? _heroes.Max(h => h.Id) + 1 : 1,
            FirstName = dto.FirstName,
            LastName = dto.LastName,
            IsActive = dto.IsActive
        };
        _heroes.Add(hero);
        return hero;
    }
    public OurHero? Update(int id, AddUpdateOurHero dto) {
        var hero = _heroes.FirstOrDefault(h => h.Id == id);
        if (hero == null) return null;
        hero.FirstName = dto.FirstName;
        hero.LastName = dto.LastName;
        hero.IsActive = dto.IsActive;
        return hero;
    }
    public bool Delete(int id) {
        var hero = _heroes.FirstOrDefault(h => h.Id == id);
        if (hero == null) return false;
        _heroes.Remove(hero);
        return true;
    }
}
```

#### 3. Registro del servicio en Program.cs
```csharp
// En Program.csuilder.Services.AddSingleton<IOurHeroService, OurHeroService>();
```

#### 4. Controlador CRUD RESTful
```csharp
[ApiController]
[Route("api/v1/heroes")]
public class OurHeroController : ControllerBase {
    private readonly IOurHeroService _service;
    public OurHeroController(IOurHeroService service) => _service = service;

    // Obtener todos los h√©roes (con filtro opcional por activo)
    [HttpGet]
    public ActionResult<List<OurHero>> GetAll([FromQuery] bool? isActive) =>
        Ok(_service.GetAll(isActive));

    // Obtener un h√©roe por ID
    [HttpGet("{id}")]
    public ActionResult<OurHero> GetById(int id) {
        var hero = _service.GetById(id);
        return hero == null ? NotFound() : Ok(hero);
    }

    // Crear un nuevo h√©roe
    [HttpPost]
    public async Task<ActionResult<OurHero>> Create([FromBody] AddUpdateOurHero dto) {
        if (!ModelState.IsValid) return BadRequest(ModelState);
        var hero = _service.Add(dto);
        return CreatedAtAction(nameof(GetById), new { id = hero.Id }, hero);
    }

    // Actualizar un h√©roe existente
    [HttpPut("{id}")]
    public IActionResult Update(int id, [FromBody] AddUpdateOurHero dto) {
        if (!ModelState.IsValid) return BadRequest(ModelState);
        var updated = _service.Update(id, dto);
        return updated == null ? NotFound() : NoContent();
    }

    // Eliminar un h√©roe
    [HttpDelete("{id}")]
    public IActionResult Delete(int id) =>
        _service.Delete(id) ? NoContent() : NotFound();
}
```

> **Nota:** Estos ejemplos son ideales para pruebas, prototipos, onboarding y como base para implementar l√≥gica de negocio real con bases de datos.

### Negociaci√≥n de contenido y formatos
- Usa el header `Accept` para soportar JSON, XML, etc.
- Por defecto en .NET: `application/json`.
- Puedes habilitar otros formatos con `AddXmlSerializerFormatters()`.

### Ejemplo de headers de cach√© y ETag
```csharp
[HttpGet]
[ResponseCache(Duration = 60)]
public IActionResult GetAllProducts() {
    Response.Headers["Cache-Control"] = "public,max-age=60";
    Response.Headers["ETag"] = "\"abc123\"";
    return Ok(_products);
}
```

### Rate limiting (limitaci√≥n de velocidad)
- Implementa protecci√≥n ante abuso con paquetes como `AspNetCoreRateLimit`.
- Ejemplo de configuraci√≥n:
```csharp
services.AddRateLimiter(options => {
    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(
        httpContext => RateLimitPartition.GetFixedWindowLimiter(
            partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "anonimo",
            factory: _ => new FixedWindowRateLimiterOptions {
                PermitLimit = 100,
                Window = TimeSpan.FromMinutes(1),
                QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
                QueueLimit = 0
            })
    );
});
```

### Estructura uniforme de errores
- Devuelve errores con estructura JSON clara y autodescriptiva:
```json
{
  "success": false,
  "error": {
    "code": "ValidationError",
    "message": "Uno o m√°s errores de validaci√≥n ocurrieron.",
    "details": ["El campo Email es requerido"]
  }
}
```

## 7. Paginaci√≥n

- Usa LINQ con `Skip`/`Take` para paginaci√≥n en EF Core.
- Devuelve el header `X-Total-Count`.
- Par√°metros `page` y `pageSize` opcionales, con valores por defecto.
- Limita el `pageSize` (ej: 100).
- Documenta en Swagger los par√°metros y headers de paginaci√≥n.
- **Ejemplo:**
  ```csharp
  [HttpGet]
  public async Task<ActionResult<List<ProveedorReadDto>>> GetAll([FromQuery] int page = 1, [FromQuery] int pageSize = 10)
  {
      var query = _context.Proveedores.Where(p => p.Activo);
      var total = await query.CountAsync();
      var items = await query.Skip((page - 1) * pageSize).Take(pageSize).ToListAsync();
      Response.Headers.Add("X-Total-Count", total.ToString());
      return Ok(items);
  }
  ```

## 8. Optimizaci√≥n de Performance

- Usa async/await para operaciones I/O-bound.
- Implementa caching (`IMemoryCache`, Redis, etc.).
- Evita N+1 queries; usa `.Include()` en EF Core.
- Usa herramientas de profiling (dotTrace, BenchmarkDotNet).
- **Ejemplo incorrecto:**
  - ‚ùå Consultar toda la tabla y filtrar en memoria.

## 9. Convenciones Clave

- Usa Dependency Injection para desacoplar y testear.
- Aplica el patr√≥n Repository solo si la complejidad lo justifica.
- Usa AutoMapper para mapear DTOs/entidades.
- Implementa tareas en segundo plano con `IHostedService` o `BackgroundService`.
- **Ejemplo de DI en Minimal API:**
  ```csharp
  builder.Services.AddScoped<IProveedorService, ProveedorService>();
  ```

## 10. Testing

- Usa xUnit para tests unitarios y Moq para mocking.
- Usa `WebApplicationFactory` para tests de integraci√≥n.
- Considera testcontainers para pruebas con bases reales.
- Estructura BDD: Arrange (preparar), Act (ejecutar), Assert (verificar).
- Busca alta cobertura en l√≥gica de negocio.
- **Ejemplo recomendado:**
  ```csharp
  [Fact]
  public async Task GetAll_ReturnsPagedResults()
  {
      // Arrange
      var factory = new WebApplicationFactory<Program>();
      var client = factory.CreateClient();
      // Act
      var response = await client.GetAsync("/api/v1/proveedores?page=1&pageSize=10");
      // Assert
      response.EnsureSuccessStatusCode();
      Assert.True(response.Headers.Contains("X-Total-Count"));
  }
  ```
- **Ejemplo incorrecto:**
  - ‚ùå Test sin asserts o sin mocks.
- Recursos:
  - [xUnit Documentation](https://xunit.net/docs/getting-started/netcore/cmdline)
  - [Moq Documentation](https://github.com/moq/moq4/wiki/Quickstart)

## 11. Seguridad

- Usa middleware de autenticaci√≥n y autorizaci√≥n.
- Implementa JWT authentication para APIs stateless.
- Usa HTTPS y fuerza SSL.
- Implementa proper CORS policies.

## 12. API Documentation

- Usa Swagger/OpenAPI para documentar todos los endpoints y modelos.
- Agrega comentarios XML a controladores y modelos para mejorar la documentaci√≥n de Swagger.

## 13. CI/CD y Calidad

- Usa pipelines autom√°ticos para ejecutar tests y an√°lisis est√°tico (SonarQube, GitHub Actions, Azure DevOps, etc.).
- No permitas merge a main/master si los tests fallan o hay issues cr√≠ticos de an√°lisis est√°tico.

## 14. Git y Pull Requests

- Usa mensajes de commit descriptivos y en ingl√©s.
- Exige revisi√≥n de c√≥digo (code review) para todo PR.
- Adjunta evidencia de pruebas (screenshots, logs, etc.) en los PRs de endpoints.

## 15. Manejo de Secrets y Configuraci√≥n

- Usa Azure Key Vault, AWS Secrets Manager o User Secrets en desarrollo.
- Configura settings por ambiente con `appsettings.{Environment}.json` y variables de entorno.
- Documenta c√≥mo rotar secrets y actualizar configuraciones.

## 16. Localizaci√≥n

- Usa `IStringLocalizer` para mensajes de error y validaciones si la API ser√° multi-idioma.

## 17. Observabilidad

- Usa logging estructurado (Serilog, NLog, etc.) y correlaci√≥n de logs con `CorrelationId`.
- Implementa m√©tricas y health checks (`/health` endpoint).

## 18. Recursos de Referencia

- [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb)
- [Clean Architecture - Jason Taylor](https://github.com/jasontaylordev/CleanArchitecture)
- [Microsoft REST API Guidelines](https://github.com/microsoft/api-guidelines)
- [Minimal APIs - Docs](https://learn.microsoft.com/es-es/aspnet/core/fundamentals/minimal-apis)
- [OpenTelemetry .NET](https://opentelemetry.io/docs/instrumentation/net/)

## 19. Historial de Cambios

- 2025-07-16: Versi√≥n enterprise inicial, integraci√≥n de reglas modernas, ejemplos y ap√©ndices.


  You are a senior .NET backend developer and an expert in C#, ASP.NET Core, and Entity Framework Core.

  ## Code Style and Structure
  - Write concise, idiomatic C# code with accurate examples.
  - Follow .NET and ASP.NET Core conventions and best practices.
  - Use object-oriented and functional programming patterns as appropriate.
  - Prefer LINQ and lambda expressions for collection operations.
  - Use descriptive variable and method names (e.g., 'IsUserSignedIn', 'CalculateTotal').
  - Structure files according to .NET conventions (Controllers, Models, Services, etc.).

  ## Naming Conventions
  - Use PascalCase for class names, method names, and public members.
  - Use camelCase for local variables and private fields.
  - Use UPPERCASE for constants.
  - Prefix interface names with "I" (e.g., 'IUserService').

  ## C# and .NET Usage
  - Use C# 10+ features when appropriate (e.g., record types, pattern matching, null-coalescing assignment).
  - Leverage built-in ASP.NET Core features and middleware.
  - Use Entity Framework Core effectively for database operations.

  ## Syntax and Formatting
  - Follow the C# Coding Conventions (https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)
  - Use C#'s expressive syntax (e.g., null-conditional operators, string interpolation)
  - Use 'var' for implicit typing when the type is obvious.

  ## Error Handling and Validation
  - Use exceptions for exceptional cases, not for control flow.
  - Implement proper error logging using built-in .NET logging or a third-party logger.
  - Use Data Annotations or Fluent Validation for model validation.
  - Implement global exception handling middleware.
  - Return appropriate HTTP status codes and consistent error responses.

  ## API Design & RESTful Rules
- Sigue los principios RESTful:
  - Usa `kebab-case` para nombres de recursos: `/api/proveedores`
  - Usa sustantivos en plural, nunca verbos: `GET /api/users`
  - Representa jerarqu√≠as en la URI: `/api/users/{userId}/orders`
- M√©todos HTTP recomendados:
  - GET: obtener recursos
  - POST: crear recursos
  - PUT/PATCH: modificar recursos
  - DELETE: eliminar recursos
- C√≥digos de estado HTTP:
  - 200 OK: √©xito
  - 201 Created: recurso creado
  - 204 No Content: √©xito sin contenido
  - 400 Bad Request: error de validaci√≥n
  - 404 Not Found: no existe el recurso
  - 500 Internal Server Error: error inesperado
- Validaci√≥n y errores:
  - Usa atributos `[Required]`, `[EmailAddress]`, etc. en los modelos.
  - Devuelve mensajes de error claros y estructurados en el body.
  - Usa `ModelState.IsValid` para validar DTOs en los controllers.
- Documentaci√≥n:
  - Usa Swagger (Swashbuckle) para documentar todos los endpoints y modelos.
  - Especifica los par√°metros y respuestas esperadas.
- Seguridad:
  - Aplica `[Authorize]` donde sea necesario.
  - Configura CORS correctamente.
- Versionado:
  - Versiona la API usando la ruta (`/api/v1/resource`) o headers si es necesario.
- Recursos √∫tiles:
  - [RESTful API Design - Microsoft Docs](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design)
  - [Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)

  ## Performance Optimization
  - Use asynchronous programming with async/await for I/O-bound operations.
  - Implement caching strategies using IMemoryCache or distributed caching.
  - Use efficient LINQ queries and avoid N+1 query problems.
  - Implement pagination for large data sets.

  ## Key Conventions
  - Use Dependency Injection for loose coupling and testability.
  - Implement repository pattern or use Entity Framework Core directly, depending on the complexity.
  - Use AutoMapper for object-to-object mapping if needed.
  - Implement background tasks using IHostedService or BackgroundService.

  ## Testing

- Frameworks recomendados:
  - xUnit (preferido)
  - Moq para mocking
- Convenciones de nombres:
  - El nombre del archivo de test debe ser: `<ClaseAProbar>Tests.cs` (ejemplo: `ProveedorServiceTests.cs`)
- Cobertura:
  - Buscar cobertura cercana al 100% para la l√≥gica de negocio.
  - Excluir c√≥digo de infraestructura y configuraci√≥n.
- Anotaciones y atributos:
  - `[Fact]`: para tests unitarios simples.
  - `[Theory]`: para tests parametrizados.
  - `[InlineData]`: para pasar datos a los tests.
  - `[Collection]`: para agrupar tests que comparten contexto.
- Mocking:
  - Usar Moq para simular dependencias externas.
  - Inyectar los mocks usando el constructor.
- Estructura BDD:
  - Arrange: prepara el entorno, mocks y datos.
  - Act: ejecuta la acci√≥n a probar.
  - Assert: verifica el resultado esperado.

**Ejemplo:**
```csharp
[Fact]
public void GetAllActivosAsync_ReturnsOnlyActive()
{
    // Arrange
    var mockContext = new Mock<ProveedorDbContext>();
    // ...configurar mock...

    var service = new ProveedorService(mockContext.Object);

    // Act
    var result = service.GetAllActivosAsync();

    // Assert
    Assert.NotNull(result);
    // ...m√°s asserts...
}
```
- **Ejemplo incorrecto:**
  - ‚ùå Test sin asserts o sin mocks.
- Recursos √∫tiles:
  - [xUnit Documentation](https://xunit.net/docs/getting-started/netcore/cmdline)
  - [Moq Documentation](https://github.com/moq/moq4/wiki/Quickstart)

  ## Security
  - Use Authentication and Authorization middleware.
  - Implement JWT authentication for stateless API authentication.
  - Use HTTPS and enforce SSL.
  - Implement proper CORS policies.

  ## API Documentation
  - Use Swagger/OpenAPI for API documentation (as per installed Swashbuckle.AspNetCore package).
  - Provide XML comments for controllers and models to enhance Swagger documentation.

  Follow the official Microsoft documentation and ASP.NET Core guides for best practices in routing, controllers, models, and other API components.

---

## Ejemplo de respuesta de error uniforme
```json
{
  "success": false,
  "error": {
    "code": "ValidationError",
    "message": "Uno o m√°s errores de validaci√≥n ocurrieron.",
    "details": ["El campo Email es requerido", "El campo Nombre es requerido"]
  }
}
```

## API Versioning
- Usa el paquete Microsoft.AspNetCore.Mvc.Versioning.
- Prefiere versionado por URL (`/api/v1/resource`) o por header.
- Documenta en Swagger todas las versiones expuestas.

## Pagination

Estandariza la paginaci√≥n en todos los endpoints que devuelvan colecciones:

- Utiliza LINQ con `Skip(int)` y `Take(int)` en Entity Framework Core.
- Devuelve el header HTTP `X-Total-Count` con el total de registros disponibles.
- Los endpoints deben aceptar par√°metros de query `page` y `pageSize` (opcionales, con valores por defecto).
- No modifiques contratos existentes; la paginaci√≥n debe ser retrocompatible.
- Documenta en Swagger los par√°metros de paginaci√≥n y el header de respuesta.
- Limita el tama√±o m√°ximo de `pageSize` (ejemplo recomendado: 100).

**Ejemplo:**
```csharp
[HttpGet]
public async Task<ActionResult<List<ProveedorReadDto>>> GetAll([FromQuery] int page = 1, [FromQuery] int pageSize = 10)
{
    var query = _context.Proveedores.Where(p => p.Activo);
    var total = await query.CountAsync();
    var items = await query.Skip((page - 1) * pageSize).Take(pageSize).ToListAsync();
    Response.Headers.Add("X-Total-Count", total.ToString());
    return Ok(items);
}
```

## Rate Limiting & Throttling
- Implementa rate limiting para proteger la API de abuso (ej: AspNetCoreRateLimit).
- Limita el tama√±o m√°ximo de `pageSize` (ej: 100).

## CI/CD & Quality Gates
- Usa pipelines autom√°ticos para ejecutar tests y an√°lisis est√°tico (SonarQube, GitHub Actions, Azure DevOps, etc.).
- No permitas merge a main/master si los tests fallan o hay issues cr√≠ticos de an√°lisis est√°tico.

## Git & Pull Request Conventions
- Usa mensajes de commit descriptivos y en ingl√©s.
- Exige revisi√≥n de c√≥digo (code review) para todo PR.
- Adjunta evidencia de pruebas (screenshots, logs, etc.) en los PRs de endpoints.

## Localization
- Usa `IStringLocalizer` para mensajes de error y validaciones si la API ser√° multi-idioma.

## Observability
- Usa logging estructurado (Serilog, NLog, etc.) y correlaci√≥n de logs con `CorrelationId`.
- Implementa m√©tricas y health checks (`/health` endpoint).

## Swagger Documentation Example
```csharp
/// <summary>
/// Crea un nuevo proveedor.
/// </summary>
/// <param name="dto">Datos del proveedor.</param>
/// <returns>Proveedor creado.</returns>
[HttpPost]
public async Task<ActionResult<ProveedorReadDto>> Create([FromBody] ProveedorCreateDto dto) { ... }
```

```
